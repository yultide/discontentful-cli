import { Maybe, notEmpty } from '@/utils';
import chalk from 'chalk';
import { ContentType, Environment } from 'contentful-management';
import _ from 'lodash';
import { mkdirp } from 'mkdirp';
import fs from 'node:fs';
import os from 'node:os';
import path, { dirname } from 'node:path';
import { isDeepStrictEqual } from 'node:util';
import prettier from 'prettier';
import { prettyPrint, types } from 'recast';
import tsParser from 'recast/parsers/typescript.js';
import toAst from 'to-ast';
import { fileURLToPath } from 'url';
import { AddField, ContentfulChange, Field, ModifyDisplayField, ModifyEditorInterface, ModifyField, ModifyFieldOrder, RemoveField } from '.';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const reservedWords = [
	'break',
	'case',
	'catch',
	'class',
	'const',
	'continue',
	'debugger',
	'default',
	'delete',
	'do',
	'else',
	'export',
	'extends',
	'finally',
	'for',
	'function',
	'if',
	'import',
	'in',
	'instanceof',
	'new',
	'return',
	'super',
	'switch',
	'this',
	'throw',
	'try',
	'typeof',
	'var',
	'void',
	'while',
	'with',
	'yield',
	'enum',
	'implements',
	'interface',
	'let',
	'package',
	'private',
	'protected',
	'public',
	'static',
	'await',
	'abstract',
	'boolean',
	'byte',
	'char',
	'double',
	'final',
	'float',
	'goto',
	'int',
	'long',
	'native',
	'short',
	'synchronized',
	'throws',
	'transient',
	'volatile',
];

interface Validation {
	size?: {
		min?: number;
		max?: number;
	};
}

const builder = types.builders;

/**
 * Save contentful diff to
 * @param diff Array of contentful diffs
 */
export async function saveMigration(diff: ContentfulChange[]) {
	// create migrations
	const migrations = await Promise.all(diff.map(createMigration));

	// wrap in migrate function to export
	const migration = await wrapMigrationWithBase(builder.blockStatement(_.flatten(migrations)));

	// serialize to source code
	const migrationTS = await formatSourceCode(prettyPrint(migration, { tabWidth: 2, parser: tsParser, wrapColumn: 150, quote: 'single' }).code);
	const indexTS = await formatSourceCode(
		`
    export const files = ['migration'];
    `,
	);

	// save to local files for inspection
	await mkdirp('migration');
	fs.writeFileSync('migration/index.ts', indexTS);
	fs.writeFileSync('migration/migration.ts', migrationTS);
	console.log(`Saving migration files ${chalk.yellow('index.ts, migration.ts')}`);

	return { indexTS, migrationTS };
}

/**
 * Wraps migration statements with migrate function block
 * @param {BlockStatement} blockStatement - statements to add to migrate function
 * @returns {Program} AST program that can be rendered to javascript source
 */
export async function wrapMigrationWithBase(blockStatement: types.namedTypes.BlockStatement): Promise<types.namedTypes.Program> {
	const comment = `*
 * Generated by Contentful Tools CLI at ${new Date().toISOString()} on ${os.hostname()}
 `;
	const migration = builder.program([
		// comment
		builder.emptyStatement.from({ comments: [builder.commentBlock(comment)] }),
		// import { MigrationFunction } from 'contentful-migration'
		builder.importDeclaration([builder.importSpecifier(builder.identifier('MigrationFunction'))], builder.literal('contentful-migration')),
		// const migrate:MigrationFunction = function(migration) {...}
		builder.variableDeclaration('const', [
			builder.variableDeclarator(
				builder.identifier('migrate: MigrationFunction'),
				builder.functionExpression(null, [builder.tsTypeParameter('migration')], blockStatement),
			),
		]),
		// module.exports = migrate;
		builder.expressionStatement(
			builder.assignmentExpression('=', builder.memberExpression(builder.identifier('module'), builder.identifier('exports')), builder.identifier('migrate')),
		),
	]);

	return migration;
}

export async function createMigration(c: ContentfulChange): Promise<types.namedTypes.BlockStatement[]> {
	switch (c.type) {
		case 'addContentType': {
			return generateContentTypeMigration(c._context.lowerEnv, c._context.contentType);
		}
		case 'removeContentType': {
			return [
				builder.blockStatement([
					// BEGIN: Remove field contentType.fieldName
					builder.emptyStatement.from({
						comments: [builder.commentLine(`BEGIN: Remove contentType ${c.contentType}`)],
					}),
					// migration.deleteContentType('contentTypeName');
					builder.expressionStatement(
						builder.callExpression(builder.memberExpression(builder.identifier('migration'), builder.identifier('deleteContentType')), [
							builder.literal(c.contentType),
						]),
					),
					// END: Remove field contentType.fieldName
					builder.emptyStatement.from({
						comments: [builder.commentLine(`END: Remove field ${c.contentType}`)],
					}),
				]),
			];
		}
		case 'addField': {
			const data = c.data as AddField;
			const ctVariable = ctVariableEscape(c.contentType);
			return [
				builder.blockStatement([
					// BEGIN: Add field contentType.fieldName
					builder.emptyStatement.from({
						comments: [builder.commentLine(`BEGIN: Add field ${c.contentType}.${data.name}`)],
					}),
					// const contentType = migration.editContentType('contentTypeName');
					builder.variableDeclaration('const', [
						builder.variableDeclarator(
							builder.identifier(ctVariable),
							builder.callExpression(builder.memberExpression(builder.identifier('migration'), builder.identifier('editContentType')), [
								builder.literal(c.contentType),
							]),
						),
					]),
					// contentType.createField('fieldName', {key: value});
					builder.expressionStatement(
						builder.callExpression(builder.memberExpression(builder.identifier(ctVariable), builder.identifier('createField')), [
							builder.literal(data.name),
							// Note: we have to remove 'id' since it's already specified as the first argument in createField()
							toAst(data.field),
						]),
					),
					// END: Add field contentType.fieldName
					builder.emptyStatement.from({
						comments: [builder.commentLine(`END: Add field ${c.contentType}.${data.name}`)],
					}),
				]),
			];
		}
		case 'removeField': {
			const data = c.data as RemoveField;
			return [
				builder.blockStatement([
					// BEGIN: Remove field contentType.fieldName
					builder.emptyStatement.from({
						comments: [builder.commentLine(`BEGIN: Remove field ${c.contentType}.${data.name}`)],
					}),
					// const contentType = migration.editContentType('contentTypeName');
					builder.variableDeclaration('const', [
						builder.variableDeclarator(
							builder.identifier(ctVariableEscape(c.contentType)),
							builder.callExpression(builder.memberExpression(builder.identifier('migration'), builder.identifier('editContentType')), [
								builder.literal(c.contentType),
							]),
						),
					]),
					// contentType.deleteField('fieldName', {key: value});
					// builder.expressionStatement(deleteEditorLayout(c.contentType, data.name)),
					builder.expressionStatement(deleteField(c.contentType, data.name)),
					// END: Remove field contentType.fieldName
					builder.emptyStatement.from({
						comments: [builder.commentLine(`END: Remove field ${c.contentType}.${data.name}`)],
					}),
				]),
			];
		}
		case 'modifyField': {
			const data = c.data as ModifyField;
			const changedFields: Record<string, unknown> = {};
			for (const [name, newValue] of Object.entries(data.newField)) {
				const oldValue = data.oldField[name];
				// `type` is a required field in the IFieldOptions specification
				if (name === 'type' || !isDeepStrictEqual(oldValue, newValue)) {
					changedFields[name] = newValue;
				}
			}

			const modifyStatement: types.namedTypes.ExpressionStatement[] = [];
			if (data.oldField.type === data.newField.type) {
				// contentType.editField('fieldName', {key: value});
				modifyStatement.push(
					builder.expressionStatement(
						builder.callExpression(builder.memberExpression(builder.identifier(ctVariableEscape(c.contentType)), builder.identifier('editField')), [
							builder.literal(data.name),
							toAst(changedFields),
						]),
					),
				);
			} else {
				// contentType.deleteEditorLayout('fieldName')
				// contentType.deleteField('fieldName')
				// modifyStatement.push(builder.expressionStatement(deleteEditorLayout(c.contentType, data.name)));
				modifyStatement.push(builder.expressionStatement(deleteField(c.contentType, data.name)));
				// contentType.createField('fieldName')....
				modifyStatement.push(builder.expressionStatement(createField(c.contentType, data.newField)));
			}

			return [
				builder.blockStatement([
					// BEGIN: Modify field contentType.fieldName
					builder.emptyStatement.from({
						comments: [builder.commentLine(`BEGIN: Modify field ${c.contentType}.${data.name}`)],
					}),
					// const contentType = migration.getContentType('contentTypeName');
					builder.variableDeclaration('const', [
						builder.variableDeclarator(
							builder.identifier(ctVariableEscape(c.contentType)),
							builder.callExpression(builder.memberExpression(builder.identifier('migration'), builder.identifier('editContentType')), [
								builder.literal(c.contentType),
							]),
						),
					]),
					// contentType.editField('fieldName', {key: value});
					// or
					// contentType.deleteField('fieldName');
					// contentType.createField('fieldName', {key: value});
					...modifyStatement,
					builder.emptyStatement.from({
						comments: [builder.commentLine(`END: Modify field ${c.contentType}.${data.name}`)],
					}),
				]),
			].filter(notEmpty);
		}
		case 'modifyEditorInterface': {
			// Create code to modify editor interface that looks something like this
			// newContentModel.changeFieldControl('internalName', 'builtin', 'singleLine', {
			//   helpText: 'internal name'
			// });

			const data = c.data as ModifyEditorInterface;
			return [
				builder.blockStatement([
					// BEGIN: Modify editor interface contentType.fieldName
					builder.emptyStatement.from({
						comments: [builder.commentLine(`BEGIN: Modify editor interface ${c.contentType}.${data.name}`)],
					}),
					// const contentType = migration.getContentType('contentTypeName');
					builder.variableDeclaration('const', [
						builder.variableDeclarator(
							builder.identifier(ctVariableEscape(c.contentType)),
							builder.callExpression(builder.memberExpression(builder.identifier('migration'), builder.identifier('editContentType')), [
								builder.literal(c.contentType),
							]),
						),
					]),
					// contentType.changeFieldControl(internalName', 'builtin', 'singleLine', { helpText: 'internal name' });
					builder.expressionStatement(
						changeFieldControl(
							c.contentType,
							data.newControl.fieldId,
							data.newControl.widgetNamespace || '',
							data.newControl.widgetId || '',
							data.newControl.settings,
						),
					),
					// END: Modify editor interface contentType.fieldName
					builder.emptyStatement.from({
						comments: [builder.commentLine(`END: Modify editor interface ${c.contentType}.${data.name}`)],
					}),
				]),
			];
		}
		case 'modifyDisplayField': {
			const data = c.data as ModifyDisplayField;
			return [
				builder.blockStatement([
					builder.emptyStatement.from({
						comments: [builder.commentLine(`BEGIN: Modify displayField ${c.contentType}.displayField`)],
					}),
					builder.variableDeclaration('const', [
						builder.variableDeclarator(
							builder.identifier(ctVariableEscape(c.contentType)),
							builder.callExpression(builder.memberExpression(builder.identifier('migration'), builder.identifier('editContentType')), [
								builder.literal(c.contentType),
							]),
						),
					]),
					builder.expressionStatement(
						builder.callExpression(builder.memberExpression(builder.identifier(ctVariableEscape(c.contentType)), builder.identifier('displayField')), [
							builder.stringLiteral(data.newDisplayField),
						]),
					),
					// END: Modify editor interface contentType.fieldName
					builder.emptyStatement.from({
						comments: [builder.commentLine(`END: Modify displayField ${c.contentType}.displayField`)],
					}),
				]),
			];
		}
		case 'modifyFieldOrder': {
			const data = c.data as ModifyFieldOrder;
			return [
				builder.blockStatement([
					builder.emptyStatement.from({
						comments: [builder.commentLine(`BEGIN: Modify field order ${c.contentType}`)],
					}),
					builder.variableDeclaration('const', [
						builder.variableDeclarator(
							builder.identifier(ctVariableEscape(c.contentType)),
							builder.callExpression(builder.memberExpression(builder.identifier('migration'), builder.identifier('editContentType')), [
								builder.literal(c.contentType),
							]),
						),
					]),
					...data.newContentType.fields.map((field, i) => {
						const callExpression = builder.callExpression(
							builder.memberExpression(builder.identifier(ctVariableEscape(c.contentType)), builder.identifier('moveField')),
							[builder.literal(field.id)],
						);
						const chain = i === 0 ? [['toTheTop', '']] : [['afterField', data.newContentType.fields[i - 1].id]];

						return builder.expressionStatement(createCallChain(callExpression, chain));
					}),
					builder.emptyStatement.from({
						comments: [builder.commentLine(`END: Modify field order ${c.contentType}`)],
					}),
				]),
			];
		}
		default:
			return [];
	}
}

/**
 * Generate javascript source code for a migration.
 * @param {Environment} environment - Contentful environment to find contentType
 * @param {string} contentType - content type to generate migration for
 * @returns {BlockStatement} AST object that can be rendered to javascript source
 */
async function generateContentTypeMigration(environment: Environment, contentType: ContentType): Promise<types.namedTypes.BlockStatement[]> {
	console.log(`Creating migration for content type: ${chalk.cyan(contentType.sys.id)}`);

	const fieldCreators = contentType.fields.map((field) => builder.expressionStatement(createField(contentType.sys.id, field as Field)));

	let editorInterfacesCreators: types.namedTypes.ExpressionStatement[] = [];
	try {
		console.log('Fetching editor interface');

		const editorInterface = await environment.getEditorInterfaceForContentType(contentType.sys.id);
		editorInterfacesCreators = contentType.fields
			.map((field) => {
				const control = _.find(editorInterface.controls, (c) => c.fieldId === field.id);

				if (!control) return undefined;

				const { widgetId, settings, widgetNamespace = 'builtin' } = control;

				return builder.expressionStatement(changeFieldControl(contentType.sys.id, field.id, widgetNamespace, widgetId || '', settings));
			})
			.filter(notEmpty);
	} catch (e) {
		const err = e as Error;
		if (err.name === 'NotFound') {
			console.log('Skipping editor interfaces. Content type has no fields.');
		} else {
			console.warn(err);
		}
	}

	return [
		builder.blockStatement([
			builder.emptyStatement.from({
				comments: [builder.commentLine(`BEGIN: Create content type ${contentType.sys.id}`)],
			}),
			// create content type
			createContentType(contentType),
			// create fields
			...fieldCreators,
			// create editor ui
			...editorInterfacesCreators,
			builder.emptyStatement.from({
				comments: [builder.commentLine(`END: Create content type ${contentType.sys.id}`)],
			}),
		]),
	];
}

function ctNameNeedsEscaping(ctId: string) {
	if (reservedWords.indexOf(ctId) !== -1) {
		return true;
	}

	return false;
}

function ctVariableEscape(ctId: string) {
	const camelCased = _.camelCase(ctId.replace('.', ''));
	return ctNameNeedsEscaping(camelCased) ? `_${camelCased}` : camelCased;
}

function createCallChain(base: types.namedTypes.CallExpression, chain: string[][]): types.namedTypes.CallExpression {
	if (chain.length === 0) {
		return base;
	}

	const [identifier, value] = chain[0];
	const rest = chain.slice(1);

	const args = value === '' ? [] : [toAst(value)];
	return createCallChain(builder.callExpression(builder.memberExpression(base, builder.identifier(identifier)), args), rest);
}

function createField(ctId: string, field: Field) {
	const fieldId = field.id;
	const ctVariable = ctVariableEscape(ctId);

	const chain = Object.keys(_.omit(field, 'id')).map((key) => [key, field[key]]) as string[][];

	// validate field value for validations
	const validations = field.validations as Maybe<Validation[]>;
	if (validations && validations.length > 0) {
		// can sometimes get size { min: null, max: 10 }. make sure we set both if max is defined
		validations
			.filter((v) => v.size !== undefined)
			.forEach((v) => {
				// contentful migration requires both min and max to be set so if only max has a value, we set min to be 0
				if (v.size?.max !== undefined && (v.size.min === undefined || v.size.min === null)) {
					v.size.min = 0;
				}
			});
	}

	return createCallChain(
		builder.callExpression(builder.memberExpression(builder.identifier(ctVariable), builder.identifier('createField')), [builder.literal(fieldId as string)]),
		chain,
	);
}

function deleteField(ctId: string, fieldId: string) {
	const ctVariable = ctVariableEscape(ctId);
	return builder.callExpression(builder.memberExpression(builder.identifier(ctVariable), builder.identifier('deleteField')), [builder.literal(fieldId)]);
}

function changeFieldControl(
	ctId: string,
	fieldId: string,
	widgetNamespace: string,
	widgetId: string,
	settings: Record<string, string | boolean | null | number | RegExp> = {},
) {
	const ctVariable = ctVariableEscape(ctId);

	const settingsExpression = builder.objectExpression(_.map(settings, (v, k) => builder.property('init', builder.identifier(k), builder.literal(v))));

	return builder.callExpression(builder.memberExpression(builder.identifier(ctVariable), builder.identifier('changeFieldControl')), [
		builder.literal(fieldId),
		builder.literal(widgetNamespace),
		builder.literal(widgetId),
		settingsExpression,
	]);
}

function createContentType(ct: ContentType) {
	const { id } = ct.sys;
	const { name, description, displayField } = ct;
	const chain = [
		['name', name],
		['description', description],
		['displayField', displayField],
	].filter(([, value]) => value !== null);

	const variableName = ctVariableEscape(id);

	const createCallExpression = builder.callExpression(builder.memberExpression(builder.identifier('migration'), builder.identifier('createContentType')), [
		builder.literal(id),
	]);

	const callChain = createCallChain(createCallExpression, chain);

	const withDeclaration = builder.variableDeclaration('const', [builder.variableDeclarator(builder.identifier(variableName), callChain)]);

	return withDeclaration;
}

export async function formatSourceCode(src: string) {
	const defaultOptions = await prettier.resolveConfig(path.join(__dirname, '..', '..', '.prettierrc.cjs'));
	const options = { ...defaultOptions, parser: 'typescript' };
	return prettier.format(src, options || undefined);
}
